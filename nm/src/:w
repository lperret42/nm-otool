/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bin_64.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lperret <marvin@42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2018/04/16 16:52:37 by lperret           #+#    #+#             */
/*   Updated: 2018/04/24 12:54:14 by lperret          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nm.h"

static t_sym		get_sym(char debug, unsigned long value,
													int n_sect, char letter)
{
	t_sym		sym;

	sym.for_debug = debug;
	sym.value = (letter == 'u' || letter == 'U') ? -1 : value;
	sym.n_sect = n_sect;
	sym.letter = letter;
	return (sym);
}

static t_sym		*get_syms(struct symtab_command *symtab, char *ptr)
												//char **sections_name)
{
	uint32_t			i;
	t_sym				*syms;
	struct nlist_64		*array;
	char				*section_name;
	//char				letter;

	if (!(syms = (t_sym*)ft_memalloc(sizeof(t_sym) * symtab->nsyms)))
		return (NULL);
	//if (!check_addr(NULL, (size_t)((void*)ptr + symtab->symoff)))
	if (check_addr(NULL, NULL, (size_t)((void*)ptr + symtab->symoff)) != 0)
		return (NULL);
	//if (!(array = (struct nlist_64 *)check_addr(ptr + symtab->symoff, sizeof(*array))))
	if (check_addr((void**)&array, ptr + symtab->symoff, sizeof(*array)) != 0)
		return (NULL);
	i = 0;
	while (i < symtab->nsyms)
	{
		if (check_addr(NULL, (void*)&array[i], 0) != 0)
			return (NULL);
		section_name = array[i].n_sect == NO_SECT ? NULL :
						//sections_name[array[i].n_sect - 1];
						glob()->sec_names[array[i].n_sect - 1];
		//letter = get_type(array[i].n_type, array[i].n_sect, section_name);
		syms[i] = get_sym(array[i].n_type & N_STAB ? 1 : 0, array[i].n_value,
	array[i].n_sect, get_type(array[i].n_type, array[i].n_sect, section_name));
		//syms[i].name = ptr + symtab->stroff + array[i].n_un.n_strx;
		if (check_addr((void**)&syms[i].name, ptr + symtab->stroff + array[i].n_un.n_strx, 0 ) != 0)
			return (NULL);
		i++;
	}
	//free(sections_name);
	free(glob()->sec_names);
	return (syms);
}

int					handle_64(char *p)
{
	uint32_t				i;
	struct mach_header_64	*head;
	struct load_command		*lc;
	t_sym					*syms;

	if (check_addr((void**)&head, p, sizeof(*head)) != 0)
		return (FORMAT_ERROR);
	if (check_addr((void**)&lc, p + sizeof(*head), sizeof(*lc)) != 0)
		return (FORMAT_ERROR);
	if (get_sec_names(lc, head->ncmds) != 0)
		return (FORMAT_ERROR);
	if (!glob()->sec_names)
		return (MALLOC_ERROR);
	i = -1;
	while (++i < head->ncmds)
	{
		if (lc->cmd == LC_SYMTAB)
		{
			if (check_addr(NULL, lc, sizeof(struct symtab_command)) != 0)
				return (FORMAT_ERROR);
			if (!(syms = get_syms((struct symtab_command *)lc, p)))
				return (FORMAT_ERROR);
			quick_sort_syms(syms, ((struct symtab_command *)lc)->nsyms, glob()->flags);
			print_syms(syms, ((struct symtab_command *)lc)->nsyms, glob()->flags, 64);
			free(syms);
			break ;
		}
		if (check_addr((void**)&lc, (void*)lc + lc->cmdsize, sizeof(*lc)) != 0)
			return (FORMAT_ERROR);
	}
	return (0);
}
